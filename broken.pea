f({ user: User(u) }) = u

# Better Schema error messages 

# top level paren-less calling
f 3

# List schema should check bound variables
schema Same = [id, id]
Same(a) := [1, 2] # fails

# rendering custom elements at base line
def Main
  [state, setState] = useState nil
end




class Main < Component
  def view(_)
    <User name="marcelle" />
  end
end

# `else` in `case` - maybe we don't need this??
case val
else
end


# export default

export default value

# pspec should not be a bash script!

# splats in destructuring
# nested destructuring
schema User = { id, email, child }

User({ id, child: { *child } }) := { id: 10, email: "email", child: { id: 11 } }

print id, child

# splats for arrays

# schemas in anon-functions
[{ id: 10 }].map { id } => id * 10
# don't use Schema.case !

# classes should be valid schemas, but don't allow destructuring

# think about adding decorators so we could do something like this
@returns List<User>
def get_users
end

# schema params
schema List<T> = l => l.is_a?(List) && l.every(&T.valid?)

#{ % > 0 }

arr.map &.slice ","
# optional param naming to #{} syntax
arr.map item => item * 10
# arrow functions are allowed to be multi-line if they are in parens/braces
arr.map(item =>
  console.log(item)
  item * 10
)

# implement Regex

# Think about!
# 1. MutableRecord & MutableList
#   to think about.. should we add a mutable API to all records?
#   we could make it like MutableRecord < Record
#   & MutableRecords are not usable in Component state or props
# 2. use = instead of := !!!

# Use Component instead of Component

# use arrow functions for one liners instead of #{}

# schema constructors when they have a param
schema Success<T> = { data: T }

successful_response = Success(10)

assert! successful_response == { data: 10 }

# tuples? maybe - idk, immutable lists are good enough

# schemas should be able to be in class definitions

class User < Component
  schema State = { id, created_at }
  def data_source = "/api/users"
end

# maybe User could use this?
# Idk, it just looks pretty

# Int & Float should fake being objects

a + b
# should turn into 
_plus(a, b)

1.to_i
# turn into
_send(1, "to_i")

# hash shorthand when calling
def fun({ x, y })
  x * y
end

# do we wanna do this too?
# I think yes, because it makes pattern matching look really nice
def fun(x:, y:)
  x * y
end

fun(x: 10, y: 10)

# doc strings would be sick

def learning
  """
  How to read things
  """
end

# multi-line arrow functions if surrounded in parens
[1, 2, 3].map(x => 
  y := x * 10
  y
)

# Component#view & #style should take records
class Main < Component
  def view(state: nil)

  end

  def view(props: [])

  end
end