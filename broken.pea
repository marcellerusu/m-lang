f({ user: User(u) }) = u

# Better Schema error messages 

# top level paren-less calling
f 3

# List schema should check bound variables
schema Same = [id, id]
Same(a) := [1, 2] # fails

# rendering custom elements at base line
class Main < Element
  def view(_, _, _)
    <User name="marcelle" />
  end
end

# `else` in `case` - maybe we don't need this??
case val
else
end


# export default

export default value

# pspec should not be a bash script!

# splats in destructuring
# nested destructuring
schema User = { id, email, child }

User({ id, child: { *child } }) := { id: 10, email: "email", child: { id: 11 } }

print(id, child)

# splats for arrays

# schemas in anon-functions
[{ id: 10 }].map do { id } id * 10 end
# don't use Schema.case !

# classes should be valid schemas, but don't allow destructuring

# think about adding decorators so we could do something like this
@returns List<User>
def get_users
end

# schema params
schema List<T> = #{%.is_a?(List) && %.every(&T.valid?)}

# optional param naming to #{} syntax
arr.map #{ |item| item * 10 }

# implement Regex