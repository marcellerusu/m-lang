declare Peacock.Token exposing (Token)

TOKENS = {
  "=" => :assign,
  "(" => :open-parenthesis,
  ")" => :close-parenthesis,
  "{" => :open-brace,
  "}" => :close-brace,
  "[" => :open-square-bracket,
  "]" => :close-square-bracket,
  "=>" => :arrow,
  ":" => :colon,
  "," => :comma,
  # Operators
  "==" => :eq,
  "!=" => :not-eq,
  "|>" => :pipe,
  "*" => :mult,
  "/" => :div,
  "+" => :plus,
  "-" => :minus,
  "true" => :true,
  "false" => :false,
  "return" => :return,
  # Constructs
  "if" => :if,
  "else" => :else,
  "reduce" => :reduce
}

class Token @token, @line, @start-index =
  @index = 0

  clone = Token.new @token, @line

  undo! =
    @index -= 1
    @token = @token.chop
    self

  consume! char =
    @index += 1
    @token += char

  full-token? =
    @token = peek-rest-of-token.token

  invalid? = !valid?

  valid? = keyword? || literal? || symbol? || identifier?

  as-token =
    return as-literal if literal?
    return as-keyword if keyword?
    return as-identifier if identifier?
    return as-symbol if symbol?
  
  as-keyword = [@start-index, TOKENS[@token]]

  as-identifier = [@start-index, :identifier, @token]

  as-symbol = [@start-index, :symbol, @token]

  as-literal a x with x := 3 =
    return [@start-index, :int-lit, as-int] if int?
    return [@start-index, :float-lit, as-float] if float?
    return [@start-index, :str-lit, as-str] if str?

  symbol? =
    return false if @token.first != ':'
    return Token.new(@token.delete-prefix(":"), nil, nil).identifier?

  identifier? =
    return false if TOKENS.include?(@token)
    return false if @token.match /[\s]/
    return false unless @token.match /^[a-zA-Z][a-zA-Z1-9]*$/
    return true

  keyword? = TOKENS[token].exists?

  literal? = int? || float? || str?

  empty? = @token.empty?

  str? = @token.match /^".*"$/

  as-str = @token.slice 1, -2

  int? = as-int.to-s == @token

  as-int = @token.to-i

  float? =
    return clone.undo!.int? if @token[-1] == "."
    as-float.to-s == @token

  as-float = @token.to-f

  peek-rest-of-token =
    return self if @index >= @line.size
    return peek-string || self if @token.first == '"'

    peek-token = Token.new @token, @line, @start-index
    reduce peek-token
      peek-token.consume! char
      break peek-token.undo! if peek-token.invalid?
      next peek-token
    end

  peek-string = 
    i = @line.slice(@index + 1).index '"'
    Token.new @line.slice(@index, i + 1), @line, @start-index unless i.nil?
